[
  {
    "id": "intro_q1",
    "question": "Jaký je primární cíl předmětu KIV/ADT (dle úvodní prezentace)?",
    "options": [
      "Naučit se programovat v Pythonu od základů.",
      "Porozumět základním abstraktním datovým typům a algoritmům.",
      "Specializovat se na vývoj webových aplikací.",
      "Zaměřit se na hardware a architekturu počítačů.",
      "Naučit se používat AI pro generování kódu."
    ],
    "correctAnswerIndex": 1
  },
  {
    "id": "intro_q2",
    "question": "Co znamená <pre><code>if __name__ == \"__main__\":</code></pre> v Python skriptu?",
    "options": [
      "Definuje hlavní třídu programu.",
      "Importuje hlavní modul.",
      "Spustí následující blok kódu pouze tehdy, když je skript spuštěn přímo.",
      "Kontroluje, zda je název skriptu \"main.py\".",
      "Deklaruje globální proměnné pro hlavní funkci."
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "intro_q3",
    "question": "Která z následujících kolekcí v Pythonu je typicky *neměnitelná* (immutable)?",
    "options": [
      "Seznam (`list`)",
      "Slovník (`dict`)",
      "Množina (`set`)",
      "N-tice (`tuple`)",
      "Fronta (`deque`)"
    ],
    "correctAnswerIndex": 3
  },
  {
    "id": "intro_q4",
    "question": "Jaký bude výstup následujícího kódu?<br><pre><code>my_tuple = (10, 20, 30)\nmy_tuple[1] = 25\nprint(my_tuple)</code></pre>",
    "options": [
      "(10, 25, 30)",
      "(10, 20, 30)",
      "TypeError",
      "IndexError",
      "None"
    ],
    "correctAnswerIndex": 2
  },
    {
    "id": "intro_q5",
    "question": "Co vypíše následující kód?<br><pre><code>my_list = [1, 'a', True]\nprint(type(my_list))</code></pre>",
    "options": [
      "'list'",
      "'tuple'",
      "'str'",
      "'int'",
      "Chyba, nelze kombinovat typy."
    ],
    "correctAnswerIndex": 0
  },
  {
    "id": "complexity_q1",
    "question": "Jaká je časová složitost algoritmu, který hledá prvek v setříděném poli pomocí binárního vyhledávání?",
    "options": [
      "Θ(log n)",
      "Θ(n)",
      "Θ(n log n)",
      "Θ(1)",
      "Θ(n^2)"
    ],
    "correctAnswerIndex": 0
  },
  {
    "id": "complexity_q2",
    "question": "Máme algoritmus AlgA se složitostí Θ(n^2) a AlgB se složitostí O(n). Jaké tvrzení je pravdivé o jejich složitosti pro velké hodnoty n?",
    "options": [
      "AlgA má vždy vyšší nebo stejnou asymptotickou složitost než AlgB.",
      "AlgA má vždy nižší asymptotickou složitost než AlgB.",
      "AlgA a AlgB mají stejnou asymptotickou složitost.",
      "Na základě poskytnutých údajů nemůžeme asymptotické složitosti porovnat, protože O-notace AlgB neurčuje těsnou mez.",
      "AlgB je vždy rychlejší než AlgA."
    ],
    "correctAnswerIndex": 0
  },
  {
    "id": "complexity_q3",
    "question": "Jaká je typická časová složitost operace vložení prvku do seřazeného seznamu (pole) při zachování seřazení?",
    "options": [
      "Θ(1)",
      "Θ(log n)",
      "Θ(n)",
      "Θ(n log n)",
      "Θ(n^2)"
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "complexity_q4",
    "question": "Která třída složitosti roste nejrychleji pro velké `n`?",
    "options": [
      "Θ(n log n)",
      "Θ(n^2)",
      "Θ(2^n)",
      "Θ(n!)",
      "Θ(n^3)"
    ],
    "correctAnswerIndex": 3
  },
  {
    "id": "complexity_q5",
    "question": "Co znamená, že algoritmus má konstantní časovou složitost Θ(1)?",
    "options": [
      "Algoritmus provede vždy jen jednu operaci.",
      "Doba běhu algoritmu nezávisí na velikosti vstupu.",
      "Algoritmus je extrémně rychlý.",
      "Algoritmus využívá konstantní množství paměti.",
      "Algoritmus pracuje pouze s jedním prvkem."
    ],
    "correctAnswerIndex": 1
  },
    {
    "id": "complexity_q6",
    "question": "Jaká je časová složitost algoritmu Mergesort?",
    "options": [
      "Θ(n^2)",
      "Θ(n)",
      "Θ(log n)",
      "Θ(n log n)",
      "Θ(1)"
    ],
    "correctAnswerIndex": 3
  },
  {
    "id": "complexity_q7",
    "question": "Jakou časovou složitost má rekurzivní výpočet Fibonacciho posloupnosti bez memoizace (ukládání mezivýsledků)?",
    "options": [
      "Lineární Θ(n)",
      "Logaritmickou Θ(log n)",
      "Exponenciální (přibližně Θ(1.618^n))",
      "Kvadratickou Θ(n^2)",
      "Konstantní Θ(1)"
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "complexity_q8",
    "question": "Algoritmus má časovou složitost T(n) = 5n^2 + 100n + log(n). Jaká je jeho asymptotická složitost v Θ notaci?",
    "options": [
      "Θ(log n)",
      "Θ(n)",
      "Θ(n log n)",
      "Θ(n^2)",
      "Θ(n^3)"
    ],
    "correctAnswerIndex": 3
  },
  {
    "id": "complexity_q9",
    "question": "Co vyjadřuje Θ-notace (Big Theta)?",
    "options": [
      "Pouze horní odhad růstu funkce.",
      "Pouze dolní odhad růstu funkce.",
      "Asymptoticky těsný odhad růstu funkce (horní i dolní).",
      "Nejlepší možný čas běhu algoritmu.",
      "Nejhorší možný čas běhu algoritmu."
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "complexity_q10",
    "question": "Pokud algoritmus A má složitost Θ(n log n) a algoritmus B má složitost Θ(n^2), který algoritmus bude obecně rychlejší pro velmi velké vstupní data (n)?",
    "options": [
      "Algoritmus A",
      "Algoritmus B",
      "Budou stejně rychlé.",
      "Nelze určit bez znalosti konstant.",
      "Záleží na typu vstupních dat."
    ],
    "correctAnswerIndex": 0
  },
  {
    "id": "complexity_q11",
    "question": "Jaká je časová složitost následujícího kódu, kde `n` je délka seznamu `arr`?<br><pre><code>for i in range(n):\n    for j in range(n):\n        print(arr[i][j])</code></pre>",
    "options": [
      "Θ(1)",
      "Θ(n)",
      "Θ(n log n)",
      "Θ(n^2)",
      "Θ(2^n)"
    ],
    "correctAnswerIndex": 3
   },
  {
    "id": "adt_q1",
    "question": "Jaký je hlavní rozdíl mezi rozhraním (interface) a abstraktním datovým typem (ADT)?",
    "options": [
      "Rozhraní definuje pouze metody, ADT i atributy.",
      "ADT je myšlenkový koncept se sémantikou (významem operací), rozhraní definuje signatury metod.",
      "Rozhraní je specifické pro Python, ADT je obecný.",
      "ADT vždy specifikuje časovou složitost operací, rozhraní ne.",
      "Rozhraní nemůže být implementováno, ADT ano."
    ],
    "correctAnswerIndex": 1
  },
  {
    "id": "adt_q2",
    "question": "Která kolekce typicky *neumožňuje* duplicitní prvky?",
    "options": [
      "Seznam (List)",
      "Zásobník (Stack)",
      "Fronta (Queue)",
      "Množina (Set)",
      "Spojový seznam (Linked List)"
    ],
    "correctAnswerIndex": 3
  },
  {
    "id": "adt_q3",
    "question": "Co je hlavním účelem iterátoru v Pythonu?",
    "options": [
      "Umožnit efektivní řazení kolekce.",
      "Poskytnout jednotný způsob procházení prvků kolekce (nebo generované sekvence) bez nutnosti znát její vnitřní strukturu.",
      "Zajistit neměnnost (immutability) kolekce.",
      "Implementovat hashovací funkci pro kolekci.",
      "Optimalizovat paměťové nároky kolekce uložením pouze jednoho prvku."
    ],
    "correctAnswerIndex": 1
  },
  {
    "id": "adt_q6",
    "question": "Jaký je hlavní rozdíl mezi ADT Seznam (List) a ADT Množina (Set)?",
    "options": [
      "Seznam může obsahovat duplicity a záleží na pořadí, Množina neobsahuje duplicity a na pořadí nezáleží.",
      "Množina je vždy rychlejší pro přístup k prvkům.",
      "Seznam nemůže obsahovat různé datové typy.",
      "Množina je neměnitelná (immutable), Seznam je měnitelný (mutable).",
      "Seznam se používá pro klíč-hodnota páry, Množina pro jednotlivé prvky."
    ],
    "correctAnswerIndex": 0
  },
  {
    "id": "adt_q7",
    "question": "Která metoda se typicky volá pro přidání prvku na vrchol ADT Zásobník?",
    "options": [
      "`enqueue`",
      "`dequeue`",
      "`push` (nebo `append` v Python list implementaci)",
      "`popleft`",
      "`insert`"
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "adt_q8",
    "question": "Která operace je charakteristická pro ADT Fronta (odebírání) a odlišuje ji od Zásobníku?",
    "options": [
      "Přidání prvku na konec (`enqueue`/`append`).",
      "Odebrání prvku z konce (`pop`).",
      "Odebrání prvku ze začátku (`dequeue`/`popleft`).",
      "Zjištění počtu prvků (`size`/`len`).",
      "Kontrola, zda je prvek přítomen (`contains`)."
    ],
    "correctAnswerIndex": 2
   },
   {
    "id": "adt_q9",
    "question": "Proč nemohou být standardní měnitelné (mutable) typy jako `list` nebo `set` použity jako klíče v ADT Tabulka (Python `dict`)?",
    "options": [
        "Protože by to bylo příliš pomalé.",
        "Protože jejich hodnota se může změnit, což by narušilo konzistenci hash tabulky (jejich hash by se musel přepočítat a prvek potenciálně přesunout).",
        "Protože zabírají příliš mnoho paměti.",
        "Protože Python to syntakticky nepovoluje pro tyto konkrétní typy.",
        "Protože klíče musí být vždy čísla nebo řetězce."
     ],
     "correctAnswerIndex": 1
   },
  {
    "id": "ds_q1_linkedlist",
    "question": "Jaká je hlavní výhoda spojového seznamu (Linked List) oproti poli (array-based list) při vkládání nebo mazání prvku *uprostřed* seznamu, pokud známe ukazatel na předchozí prvek?",
    "options": [
      "Rychlejší přístup k prvku na libovolném indexu (Θ(1)).",
      "Menší paměťová náročnost.",
      "Rychlejší vložení/smazání (Θ(1)) bez nutnosti posouvat ostatní prvky.",
      "Možnost uložit více různých datových typů.",
      "Snadnější implementace binárního vyhledávání."
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "ds_q2_deque",
    "question": "Která Pythonovská struktura z modulu `collections` efektivně implementuje operace na obou koncích (přidání/odebrání) a je vhodná pro implementaci fronty i zásobníku?",
    "options": [
      "`list`",
      "`tuple`",
      "`dict`",
      "`set`",
      "`deque`"
    ],
    "correctAnswerIndex": 4
  },
  {
    "id": "ds_q3_hash",
    "question": "Proč je důležité, aby objekty používané jako klíče ve slovníku (`dict`) implementovaly správně metody `__eq__` a `__hash__`?",
    "options": [
      "Aby bylo možné objekty tisknout (`__str__` nebo `__repr__` jsou pro tisk).",
      "Aby bylo možné slovník seřadit (klíče musí být porovnatelné `<`).",
      "Aby hashovací tabulka mohla správně určit přihrádku (pomocí `__hash__`) a ověřit rovnost klíčů při kolizi (pomocí `__eq__`).",
      "Aby bylo možné použít dědičnost (`super()`).",
      "Aby se snížila paměťová náročnost (to nesouvisí)."
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "ds_q4_numpy",
    "question": "Jaký je hlavní rozdíl mezi vícerozměrným seznamem Pythonu (`list[list[int]]`) a NumPy polem (`np.ndarray`) z hlediska výkonu a paměti?",
    "options": [
      "Seznamy Pythonu jsou vždy rychlejší a paměťově úspornější.",
      "NumPy pole jsou obecně pomalejší pro matematické operace, ale zabírají méně paměti.",
      "Seznamy Pythonu umožňují heterogenní data, NumPy pole jsou rychlejší a paměťově efektivnější pro homogenní numerická data a umožňují vektorizované operace.",
      "NumPy pole nepodporují slicing (řezání).",
      "Seznamy Pythonu mají fixní velikost, NumPy pole dynamickou."
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "hash_q1",
    "question": "Co se stane v hash tabulce, pokud dva různé klíče mají stejnou hash hodnotu?",
    "options": [
       "Dojde k chybě programu.",
       "Jeden z klíčů je přepsán.",
       "Dojde ke kolizi, která se musí řešit (např. řetězením nebo otevřenou adresací).",
       "Hash tabulka automaticky zvětší svou velikost.",
       "Hash funkce se automaticky změní."
    ],
    "correctAnswerIndex": 2
   },
   {
    "id": "hash_q2",
    "question": "Jaké objekty v Pythonu mohou být typicky použity jako klíče ve slovníku (dict)?",
    "options": [
       "Pouze řetězce.",
       "Pouze čísla.",
       "Jakékoliv objekty.",
       "Pouze měnitelné (mutable) objekty.",
       "Pouze neměnitelné (immutable) objekty, které mají definovanou metodu __hash__."
    ],
    "correctAnswerIndex": 4
   },
  {
    "id": "hash_q3",
    "question": "Co je hlavním účelem hashovací (rozptylové) funkce v kontextu hash tabulek a množin?",
    "options": [
      "Seřadit data v tabulce.",
      "Komprimovat data pro úsporu místa.",
      "Efektivně převést klíč (nebo prvek) na index (adresu přihrádky) v interní datové struktuře (obvykle poli).",
      "Zajistit unikátnost klíčů.",
      "Šifrovat klíče pro bezpečnost."
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "hash_q4",
    "question": "Jaká je ideální (očekávaná, průměrná) časová složitost operací přidání (`add`), vyhledání (`in`) a smazání (`remove`) v Python `set` nebo `dict`?",
    "options": [
      "Θ(1)",
      "Θ(log n)",
      "Θ(n)",
      "Θ(n log n)",
      "Θ(n^2)"
    ],
    "correctAnswerIndex": 0
  },
  {
    "id": "hash_q5",
    "question": "Jaká je časová složitost operací (přidání, vyhledání, smazání) v Python `set` nebo `dict` v *nejhorším* případě (např. všechny prvky hashují do stejné přihrádky)?",
    "options": [
      "Θ(1)",
      "Θ(log n)",
      "Θ(n)",
      "Θ(n log n)",
      "Θ(n^2)"
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "tree_q1",
    "question": "Jak se nazývá uzel ve stromu, který nemá žádné potomky?",
    "options": [
      "Kořen (Root)",
      "Vnitřní uzel (Internal node)",
      "List (Leaf)",
      "Rodič (Parent)",
      "Sourozenec (Sibling)"
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "tree_q2",
    "question": "Co je výška stromu?",
    "options": [
      "Počet všech uzlů ve stromu.",
      "Hloubka kořenového uzlu.",
      "Maximální hloubka libovolného uzlu ve stromu (délka nejdelší cesty od kořene k listu).",
      "Počet listů ve stromu.",
      "Počet hran ve stromu."
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "tree_q3",
    "question": "Který typ procházení stromu typicky využívá zásobník (explicitně nebo implicitně pomocí rekurze)?",
    "options": [
      "Procházení do šířky (BFS)",
      "Procházení do hloubky (DFS)",
      "Level-order traversal",
      "Pouze BFS",
      "Pouze Iterativní BFS"
      ],
    "correctAnswerIndex": 1
  },
     {
    "id": "tree_q5_completion",
    "question": "Doplňte chybějící řádek v rekurzivním kódu pro tisk stromu do hloubky (pre-order like) s odsazením. Co tento řádek zajišťuje?<br><pre><code>class TreeNode:\n    # ... (init, add_child) ...\n    def print_tree(self, indent=0):\n        print(\" \" * indent + str(self.data))\n        for child in self.children:\n            # CHYBĚJÍCÍ ŘÁDEK\n</code></pre>",
    "options": [
      "`child.print_tree(indent)`: Volá metodu pro potomka se stejným odsazením.",
      "`self.print_tree(indent + 1)`: Volá metodu na sobě samém s větším odsazením.",
      "`child.print_tree(indent + 2)`: Volá metodu pro potomka s odsazením zvětšeným o 2 (běžnější je +1 nebo + konstanta).",
      "`child.print_tree(indent + 1)`: Rekurzivně volá metodu pro potomka se zvětšeným odsazením pro vizuální hierarchii.",
      "`print(\" \" * (indent + 1) + str(child.data))` : Pouze vypíše potomka s odsazením, ale nespustí rekurzi pro jeho podstrom."
    ],
    "correctAnswerIndex": 3
  },
     {
    "id": "graph_q1",
    "question": "Co reprezentuje seznam sousednosti (adjacency list) v kontextu grafů?",
    "options": [
      "Matici, kde řádky a sloupce jsou vrcholy.",
      "Pro každý vrchol seznam vrcholů, se kterými je přímo spojen hranou.",
      "Seznam všech možných cest v grafu.",
      "Stromovou strukturu odvozenou z grafu.",
      "Seřazený seznam všech hran podle váhy."
    ],
    "correctAnswerIndex": 1
  },
  {
    "id": "graph_q2",
    "question": "Jaká je typická paměťová složitost reprezentace grafu pomocí seznamů sousednosti, kde |V| je počet vrcholů a |E| je počet hran?",
    "options": [
      "Θ(|V|)",
      "Θ(|E|)",
      "Θ(|V| + |E|)",
      "Θ(|V|^2)",
      "Θ(|V| * |E|)"
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "graph_q3",
    "question": "Jaká je typická časová složitost zjištění, zda existuje hrana mezi dvěma vrcholy `u` a `v` v grafu reprezentovaném maticí sousednosti?",
    "options": [
      "Θ(1)",
      "Θ(log |V|)",
      "Θ(|V|)",
      "Θ(|E|)",
      "Θ(|V| + |E|)"
    ],
    "correctAnswerIndex": 0
  },
    {
    "id": "graph_q4",
    "question": "Který algoritmus se typicky používá pro nalezení minimální kostry neorientovaného ohodnoceného grafu?",
    "options": [
      "BFS (Breadth-First Search)",
      "DFS (Depth-First Search)",
      "Dijkstrův algoritmus",
      "Primův (Jarníkův) nebo Kruskalův algoritmus",
      "Bellman-Fordův algoritmus"
    ],
    "correctAnswerIndex": 3
  },
    {
    "id": "graph_q5_completion",
    "question": "Doplňte chybějící podmínku v kódu pro Dijkstrův algoritmus (používající prioritní frontu `pq`), která rozhoduje, zda aktualizovat vzdálenost k sousedovi `neighbor`. Co tato podmínka kontroluje?<br><pre><code># ... (inicializace D, pq, visited)\nwhile not pq.empty():\n    dist, current_vertex = pq.get() \n    # Optimalizace: Pokud jsme vrchol již zpracovali s kratší cestou, přeskočíme\n    if dist > D.get(current_vertex, float('inf')): continue \n    if current_vertex in visited: continue # Alternativní kontrola, pokud nepoužíváme optimalizaci výše\n    visited.add(current_vertex)\n\n    for neighbor, weight in graph.neighbours(current_vertex).items():\n        if neighbor not in visited:\n            old_cost = D.get(neighbor, float('inf'))\n            new_cost = D[current_vertex] + weight\n            # CHYBĚJÍCÍ PODMÍNKA\n            if ??? :\n                D[neighbor] = new_cost\n                pq.put((new_cost, neighbor))\n</code></pre>",
    "options": [
      "`new_cost > old_cost`: Pokud je nová cesta delší.",
      "`new_cost < old_cost`: Pokud je nově nalezená cesta ke sousedovi kratší než dosud známá nejkratší cesta.",
      "`new_cost == old_cost`: Pokud jsou cesty stejně dlouhé.",
      "`neighbor == start`: Pokud je soused startovním vrcholem.",
      "`weight < dist`: Pokud je váha aktuální hrany menší než vzdálenost aktuálního vrcholu od startu."
    ],
    "correctAnswerIndex": 1
  },
  {
    "id": "algo_q1_paradigm",
    "question": "Které algoritmické paradigma rozděluje problém na menší, často překrývající se podproblémy, řeší je (typicky zdola nahoru nebo rekurzivně s memoizací) a ukládá jejich výsledky, aby se zabránilo opakovaným výpočtům?",
    "options": [
      "Hladový algoritmus",
      "Dynamické programování",
      "Rozděl a panuj",
      "Backtracking",
      "Hrubá síla"
    ],
    "correctAnswerIndex": 1
  },
  {
    "id": "algo_q2_mergesort",
    "question": "Mergesort je příkladem jakého algoritmického paradigmatu?",
    "options": [
      "Hladový algoritmus",
      "Dynamické programování",
      "Rozděl a panuj",
      "Backtracking",
      "Randomizovaný algoritmus"
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "algo_q3_dynamic",
    "question": "Jaký je klíčový rozdíl mezi dynamickým programováním a metodou \"rozděl a panuj\"?",
    "options": [
      "Dynamické programování nepoužívá rekurzi.",
      "Rozděl a panuj řeší pouze seřazovací problémy.",
      "Dynamické programování efektivně řeší problémy s *překrývajícími se* podproblémy tím, že si pamatuje (memoizuje) nebo tabeluje jejich výsledky, zatímco \"rozděl a panuj\" typicky řeší nezávislé podproblémy.",
      "Rozděl a panuj má vždy lepší časovou složitost.",
      "Dynamické programování je vždy implementováno iterativně (zdola nahoru)."
    ],
    "correctAnswerIndex": 2
  }
]