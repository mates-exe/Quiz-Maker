[
  {
    "id": "intro_q1",
    "question": "Jaký je primární cíl předmětu KIV/ADT (dle úvodní prezentace)?",
    "options": [
      "Naučit se programovat v Pythonu od základů.",
      "Porozumět základním abstraktním datovým typům a algoritmům.",
      "Specializovat se na vývoj webových aplikací.",
      "Zaměřit se na hardware a architekturu počítačů.",
      "Naučit se používat AI pro generování kódu."
    ],
    "correctAnswerIndex": 1
  },
  {
    "id": "intro_q2",
    "question": "Co znamená <pre><code>if __name__ == \"__main__\":</code></pre> v Python skriptu?",
    "options": [
      "Definuje hlavní třídu programu.",
      "Importuje hlavní modul.",
      "Spustí následující blok kódu pouze tehdy, když je skript spuštěn přímo.",
      "Kontroluje, zda je název skriptu \"main.py\".",
      "Deklaruje globální proměnné pro hlavní funkci."
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "intro_q3",
    "question": "Která z následujících kolekcí v Pythonu je typicky *neměnitelná* (immutable)?",
    "options": [
      "Seznam (`list`)",
      "Slovník (`dict`)",
      "Množina (`set`)",
      "N-tice (`tuple`)",
      "Fronta (`deque`)"
    ],
    "correctAnswerIndex": 3
  },
  {
    "id": "intro_q4",
    "question": "Jaký bude výstup následujícího kódu?<br><pre><code>my_tuple = (10, 20, 30)\nmy_tuple[1] = 25\nprint(my_tuple)</code></pre>",
    "options": [
      "(10, 25, 30)",
      "(10, 20, 30)",
      "TypeError",
      "IndexError",
      "None"
    ],
    "correctAnswerIndex": 2
  },
    {
    "id": "intro_q5",
    "question": "Co vypíše následující kód?<br><pre><code>my_list = [1, 'a', True]\nprint(type(my_list))</code></pre>",
    "options": [
      "'list'",
      "'tuple'",
      "'str'",
      "'int'",
      "Chyba, nelze kombinovat typy."
    ],
    "correctAnswerIndex": 0
  },
  {
    "id": "complexity_q1",
    "question": "Jaká je časová složitost algoritmu, který hledá prvek v setříděném poli pomocí binárního vyhledávání?",
    "options": [
      "Θ(log n)",
      "Θ(n)",
      "Θ(n log n)",
      "Θ(1)",
      "Θ(n^2)"
    ],
    "correctAnswerIndex": 0
  },
  {
    "id": "complexity_q2",
    "question": "Máme algoritmus AlgA se složitostí Θ(n^2) a AlgB se složitostí O(n). Jaké tvrzení je pravdivé o jejich složitosti pro velké hodnoty n?",
    "options": [
      "AlgA má vždy vyšší nebo stejnou asymptotickou složitost než AlgB.",
      "AlgA má vždy nižší asymptotickou složitost než AlgB.",
      "AlgA a AlgB mají stejnou asymptotickou složitost.",
      "Na základě poskytnutých údajů nemůžeme asymptotické složitosti porovnat, protože O-notace AlgB neurčuje těsnou mez.",
      "AlgB je vždy rychlejší než AlgA."
    ],
    "correctAnswerIndex": 0
  },
  {
    "id": "complexity_q3",
    "question": "Jaká je typická časová složitost operace vložení prvku do seřazeného seznamu (pole) při zachování seřazení?",
    "options": [
      "Θ(1)",
      "Θ(log n)",
      "Θ(n)",
      "Θ(n log n)",
      "Θ(n^2)"
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "complexity_q4",
    "question": "Která třída složitosti roste nejrychleji pro velké `n`?",
    "options": [
      "Θ(n log n)",
      "Θ(n^2)",
      "Θ(2^n)",
      "Θ(n!)",
      "Θ(n^3)"
    ],
    "correctAnswerIndex": 3
  },
  {
    "id": "complexity_q5",
    "question": "Co znamená, že algoritmus má konstantní časovou složitost Θ(1)?",
    "options": [
      "Algoritmus provede vždy jen jednu operaci.",
      "Doba běhu algoritmu nezávisí na velikosti vstupu.",
      "Algoritmus je extrémně rychlý.",
      "Algoritmus využívá konstantní množství paměti.",
      "Algoritmus pracuje pouze s jedním prvkem."
    ],
    "correctAnswerIndex": 1
  },
    {
    "id": "complexity_q6",
    "question": "Jaká je časová složitost algoritmu Mergesort?",
    "options": [
      "Θ(n^2)",
      "Θ(n)",
      "Θ(log n)",
      "Θ(n log n)",
      "Θ(1)"
    ],
    "correctAnswerIndex": 3
  },
  {
    "id": "complexity_q7",
    "question": "Jakou časovou složitost má rekurzivní výpočet Fibonacciho posloupnosti bez memoizace (ukládání mezivýsledků)?",
    "options": [
      "Lineární Θ(n)",
      "Logaritmickou Θ(log n)",
      "Exponenciální (přibližně Θ(1.618^n))",
      "Kvadratickou Θ(n^2)",
      "Konstantní Θ(1)"
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "complexity_q8",
    "question": "Algoritmus má časovou složitost T(n) = 5n^2 + 100n + log(n). Jaká je jeho asymptotická složitost v Θ notaci?",
    "options": [
      "Θ(log n)",
      "Θ(n)",
      "Θ(n log n)",
      "Θ(n^2)",
      "Θ(n^3)"
    ],
    "correctAnswerIndex": 3
  },
  {
    "id": "complexity_q9",
    "question": "Co vyjadřuje Θ-notace (Big Theta)?",
    "options": [
      "Pouze horní odhad růstu funkce.",
      "Pouze dolní odhad růstu funkce.",
      "Asymptoticky těsný odhad růstu funkce (horní i dolní).",
      "Nejlepší možný čas běhu algoritmu.",
      "Nejhorší možný čas běhu algoritmu."
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "complexity_q10",
    "question": "Pokud algoritmus A má složitost Θ(n log n) a algoritmus B má složitost Θ(n^2), který algoritmus bude obecně rychlejší pro velmi velké vstupní data (n)?",
    "options": [
      "Algoritmus A",
      "Algoritmus B",
      "Budou stejně rychlé.",
      "Nelze určit bez znalosti konstant.",
      "Záleží na typu vstupních dat."
    ],
    "correctAnswerIndex": 0
  },
  {
    "id": "complexity_q11",
    "question": "Jaká je časová složitost následujícího kódu, kde `n` je délka seznamu `arr`?<br><pre><code>for i in range(n):\n    for j in range(n):\n        print(arr[i][j])</code></pre>",
    "options": [
      "Θ(1)",
      "Θ(n)",
      "Θ(n log n)",
      "Θ(n^2)",
      "Θ(2^n)"
    ],
    "correctAnswerIndex": 3
   },
  {
    "id": "adt_q1",
    "question": "Jaký je hlavní rozdíl mezi rozhraním (interface) a abstraktním datovým typem (ADT)?",
    "options": [
      "Rozhraní definuje pouze metody, ADT i atributy.",
      "ADT je myšlenkový koncept se sémantikou (významem operací), rozhraní definuje signatury metod.",
      "Rozhraní je specifické pro Python, ADT je obecný.",
      "ADT vždy specifikuje časovou složitost operací, rozhraní ne.",
      "Rozhraní nemůže být implementováno, ADT ano."
    ],
    "correctAnswerIndex": 1
  },
  {
    "id": "adt_q2",
    "question": "Která kolekce typicky *neumožňuje* duplicitní prvky?",
    "options": [
      "Seznam (List)",
      "Zásobník (Stack)",
      "Fronta (Queue)",
      "Množina (Set)",
      "Spojový seznam (Linked List)"
    ],
    "correctAnswerIndex": 3
  },
  {
    "id": "adt_q3",
    "question": "Co je hlavním účelem iterátoru v Pythonu?",
    "options": [
      "Umožnit efektivní řazení kolekce.",
      "Poskytnout jednotný způsob procházení prvků kolekce (nebo generované sekvence) bez nutnosti znát její vnitřní strukturu.",
      "Zajistit neměnnost (immutability) kolekce.",
      "Implementovat hashovací funkci pro kolekci.",
      "Optimalizovat paměťové nároky kolekce uložením pouze jednoho prvku."
    ],
    "correctAnswerIndex": 1
  },
  {
    "id": "adt_q6",
    "question": "Jaký je hlavní rozdíl mezi ADT Seznam (List) a ADT Množina (Set)?",
    "options": [
      "Seznam může obsahovat duplicity a záleží na pořadí, Množina neobsahuje duplicity a na pořadí nezáleží.",
      "Množina je vždy rychlejší pro přístup k prvkům.",
      "Seznam nemůže obsahovat různé datové typy.",
      "Množina je neměnitelná (immutable), Seznam je měnitelný (mutable).",
      "Seznam se používá pro klíč-hodnota páry, Množina pro jednotlivé prvky."
    ],
    "correctAnswerIndex": 0
  },
  {
    "id": "adt_q7",
    "question": "Která metoda se typicky volá pro přidání prvku na vrchol ADT Zásobník?",
    "options": [
      "`enqueue`",
      "`dequeue`",
      "`push` (nebo `append` v Python list implementaci)",
      "`popleft`",
      "`insert`"
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "adt_q8",
    "question": "Která operace je charakteristická pro ADT Fronta (odebírání) a odlišuje ji od Zásobníku?",
    "options": [
      "Přidání prvku na konec (`enqueue`/`append`).",
      "Odebrání prvku z konce (`pop`).",
      "Odebrání prvku ze začátku (`dequeue`/`popleft`).",
      "Zjištění počtu prvků (`size`/`len`).",
      "Kontrola, zda je prvek přítomen (`contains`)."
    ],
    "correctAnswerIndex": 2
   },
   {
    "id": "adt_q9",
    "question": "Proč nemohou být standardní měnitelné (mutable) typy jako `list` nebo `set` použity jako klíče v ADT Tabulka (Python `dict`)?",
    "options": [
        "Protože by to bylo příliš pomalé.",
        "Protože jejich hodnota se může změnit, což by narušilo konzistenci hash tabulky (jejich hash by se musel přepočítat a prvek potenciálně přesunout).",
        "Protože zabírají příliš mnoho paměti.",
        "Protože Python to syntakticky nepovoluje pro tyto konkrétní typy.",
        "Protože klíče musí být vždy čísla nebo řetězce."
     ],
     "correctAnswerIndex": 1
   },
  {
    "id": "ds_q1_linkedlist",
    "question": "Jaká je hlavní výhoda spojového seznamu (Linked List) oproti poli (array-based list) při vkládání nebo mazání prvku *uprostřed* seznamu, pokud známe ukazatel na předchozí prvek?",
    "options": [
      "Rychlejší přístup k prvku na libovolném indexu (Θ(1)).",
      "Menší paměťová náročnost.",
      "Rychlejší vložení/smazání (Θ(1)) bez nutnosti posouvat ostatní prvky.",
      "Možnost uložit více různých datových typů.",
      "Snadnější implementace binárního vyhledávání."
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "ds_q2_deque",
    "question": "Která Pythonovská struktura z modulu `collections` efektivně implementuje operace na obou koncích (přidání/odebrání) a je vhodná pro implementaci fronty i zásobníku?",
    "options": [
      "`list`",
      "`tuple`",
      "`dict`",
      "`set`",
      "`deque`"
    ],
    "correctAnswerIndex": 4
  },
  {
    "id": "ds_q3_hash",
    "question": "Proč je důležité, aby objekty používané jako klíče ve slovníku (`dict`) implementovaly správně metody `__eq__` a `__hash__`?",
    "options": [
      "Aby bylo možné objekty tisknout (`__str__` nebo `__repr__` jsou pro tisk).",
      "Aby bylo možné slovník seřadit (klíče musí být porovnatelné `<`).",
      "Aby hashovací tabulka mohla správně určit přihrádku (pomocí `__hash__`) a ověřit rovnost klíčů při kolizi (pomocí `__eq__`).",
      "Aby bylo možné použít dědičnost (`super()`).",
      "Aby se snížila paměťová náročnost (to nesouvisí)."
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "ds_q4_numpy",
    "question": "Jaký je hlavní rozdíl mezi vícerozměrným seznamem Pythonu (`list[list[int]]`) a NumPy polem (`np.ndarray`) z hlediska výkonu a paměti?",
    "options": [
      "Seznamy Pythonu jsou vždy rychlejší a paměťově úspornější.",
      "NumPy pole jsou obecně pomalejší pro matematické operace, ale zabírají méně paměti.",
      "Seznamy Pythonu umožňují heterogenní data, NumPy pole jsou rychlejší a paměťově efektivnější pro homogenní numerická data a umožňují vektorizované operace.",
      "NumPy pole nepodporují slicing (řezání).",
      "Seznamy Pythonu mají fixní velikost, NumPy pole dynamickou."
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "hash_q1",
    "question": "Co se stane v hash tabulce, pokud dva různé klíče mají stejnou hash hodnotu?",
    "options": [
       "Dojde k chybě programu.",
       "Jeden z klíčů je přepsán.",
       "Dojde ke kolizi, která se musí řešit (např. řetězením nebo otevřenou adresací).",
       "Hash tabulka automaticky zvětší svou velikost.",
       "Hash funkce se automaticky změní."
    ],
    "correctAnswerIndex": 2
   },
   {
    "id": "hash_q2",
    "question": "Jaké objekty v Pythonu mohou být typicky použity jako klíče ve slovníku (dict)?",
    "options": [
       "Pouze řetězce.",
       "Pouze čísla.",
       "Jakékoliv objekty.",
       "Pouze měnitelné (mutable) objekty.",
       "Pouze neměnitelné (immutable) objekty, které mají definovanou metodu __hash__."
    ],
    "correctAnswerIndex": 4
   },
  {
    "id": "hash_q3",
    "question": "Co je hlavním účelem hashovací (rozptylové) funkce v kontextu hash tabulek a množin?",
    "options": [
      "Seřadit data v tabulce.",
      "Komprimovat data pro úsporu místa.",
      "Efektivně převést klíč (nebo prvek) na index (adresu přihrádky) v interní datové struktuře (obvykle poli).",
      "Zajistit unikátnost klíčů.",
      "Šifrovat klíče pro bezpečnost."
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "hash_q4",
    "question": "Jaká je ideální (očekávaná, průměrná) časová složitost operací přidání (`add`), vyhledání (`in`) a smazání (`remove`) v Python `set` nebo `dict`?",
    "options": [
      "Θ(1)",
      "Θ(log n)",
      "Θ(n)",
      "Θ(n log n)",
      "Θ(n^2)"
    ],
    "correctAnswerIndex": 0
  },
  {
    "id": "hash_q5",
    "question": "Jaká je časová složitost operací (přidání, vyhledání, smazání) v Python `set` nebo `dict` v *nejhorším* případě (např. všechny prvky hashují do stejné přihrádky)?",
    "options": [
      "Θ(1)",
      "Θ(log n)",
      "Θ(n)",
      "Θ(n log n)",
      "Θ(n^2)"
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "tree_q1",
    "question": "Jak se nazývá uzel ve stromu, který nemá žádné potomky?",
    "options": [
      "Kořen (Root)",
      "Vnitřní uzel (Internal node)",
      "List (Leaf)",
      "Rodič (Parent)",
      "Sourozenec (Sibling)"
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "tree_q2",
    "question": "Co je výška stromu?",
    "options": [
      "Počet všech uzlů ve stromu.",
      "Hloubka kořenového uzlu.",
      "Maximální hloubka libovolného uzlu ve stromu (délka nejdelší cesty od kořene k listu).",
      "Počet listů ve stromu.",
      "Počet hran ve stromu."
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "tree_q3",
    "question": "Který typ procházení stromu typicky využívá zásobník (explicitně nebo implicitně pomocí rekurze)?",
    "options": [
      "Procházení do šířky (BFS)",
      "Procházení do hloubky (DFS)",
      "Level-order traversal",
      "Pouze BFS",
      "Pouze Iterativní BFS"
      ],
    "correctAnswerIndex": 1
  },
     {
    "id": "tree_q5_completion",
    "question": "Doplňte chybějící řádek v rekurzivním kódu pro tisk stromu do hloubky (pre-order like) s odsazením. Co tento řádek zajišťuje?<br><pre><code>class TreeNode:\n    # ... (init, add_child) ...\n    def print_tree(self, indent=0):\n        print(\" \" * indent + str(self.data))\n        for child in self.children:\n            # CHYBĚJÍCÍ ŘÁDEK\n</code></pre>",
    "options": [
      "`child.print_tree(indent)`: Volá metodu pro potomka se stejným odsazením.",
      "`self.print_tree(indent + 1)`: Volá metodu na sobě samém s větším odsazením.",
      "`child.print_tree(indent + 2)`: Volá metodu pro potomka s odsazením zvětšeným o 2 (běžnější je +1 nebo + konstanta).",
      "`child.print_tree(indent + 1)`: Rekurzivně volá metodu pro potomka se zvětšeným odsazením pro vizuální hierarchii.",
      "`print(\" \" * (indent + 1) + str(child.data))` : Pouze vypíše potomka s odsazením, ale nespustí rekurzi pro jeho podstrom."
    ],
    "correctAnswerIndex": 3
  },
     {
    "id": "graph_q1",
    "question": "Co reprezentuje seznam sousednosti (adjacency list) v kontextu grafů?",
    "options": [
      "Matici, kde řádky a sloupce jsou vrcholy.",
      "Pro každý vrchol seznam vrcholů, se kterými je přímo spojen hranou.",
      "Seznam všech možných cest v grafu.",
      "Stromovou strukturu odvozenou z grafu.",
      "Seřazený seznam všech hran podle váhy."
    ],
    "correctAnswerIndex": 1
  },
  {
    "id": "graph_q2",
    "question": "Jaká je typická paměťová složitost reprezentace grafu pomocí seznamů sousednosti, kde |V| je počet vrcholů a |E| je počet hran?",
    "options": [
      "Θ(|V|)",
      "Θ(|E|)",
      "Θ(|V| + |E|)",
      "Θ(|V|^2)",
      "Θ(|V| * |E|)"
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "graph_q3",
    "question": "Jaká je typická časová složitost zjištění, zda existuje hrana mezi dvěma vrcholy `u` a `v` v grafu reprezentovaném maticí sousednosti?",
    "options": [
      "Θ(1)",
      "Θ(log |V|)",
      "Θ(|V|)",
      "Θ(|E|)",
      "Θ(|V| + |E|)"
    ],
    "correctAnswerIndex": 0
  },
    {
    "id": "graph_q4",
    "question": "Který algoritmus se typicky používá pro nalezení minimální kostry neorientovaného ohodnoceného grafu?",
    "options": [
      "BFS (Breadth-First Search)",
      "DFS (Depth-First Search)",
      "Dijkstrův algoritmus",
      "Primův (Jarníkův) nebo Kruskalův algoritmus",
      "Bellman-Fordův algoritmus"
    ],
    "correctAnswerIndex": 3
  },
    {
    "id": "graph_q5_completion",
    "question": "Doplňte chybějící podmínku v kódu pro Dijkstrův algoritmus (používající prioritní frontu `pq`), která rozhoduje, zda aktualizovat vzdálenost k sousedovi `neighbor`. Co tato podmínka kontroluje?<br><pre><code># ... (inicializace D, pq, visited)\nwhile not pq.empty():\n    dist, current_vertex = pq.get() \n    # Optimalizace: Pokud jsme vrchol již zpracovali s kratší cestou, přeskočíme\n    if dist > D.get(current_vertex, float('inf')): continue \n    if current_vertex in visited: continue # Alternativní kontrola, pokud nepoužíváme optimalizaci výše\n    visited.add(current_vertex)\n\n    for neighbor, weight in graph.neighbours(current_vertex).items():\n        if neighbor not in visited:\n            old_cost = D.get(neighbor, float('inf'))\n            new_cost = D[current_vertex] + weight\n            # CHYBĚJÍCÍ PODMÍNKA\n            if ??? :\n                D[neighbor] = new_cost\n                pq.put((new_cost, neighbor))\n</code></pre>",
    "options": [
      "`new_cost > old_cost`: Pokud je nová cesta delší.",
      "`new_cost < old_cost`: Pokud je nově nalezená cesta ke sousedovi kratší než dosud známá nejkratší cesta.",
      "`new_cost == old_cost`: Pokud jsou cesty stejně dlouhé.",
      "`neighbor == start`: Pokud je soused startovním vrcholem.",
      "`weight < dist`: Pokud je váha aktuální hrany menší než vzdálenost aktuálního vrcholu od startu."
    ],
    "correctAnswerIndex": 1
  },
  {
    "id": "algo_q1_paradigm",
    "question": "Které algoritmické paradigma rozděluje problém na menší, často překrývající se podproblémy, řeší je (typicky zdola nahoru nebo rekurzivně s memoizací) a ukládá jejich výsledky, aby se zabránilo opakovaným výpočtům?",
    "options": [
      "Hladový algoritmus",
      "Dynamické programování",
      "Rozděl a panuj",
      "Backtracking",
      "Hrubá síla"
    ],
    "correctAnswerIndex": 1
  },
  {
    "id": "algo_q2_mergesort",
    "question": "Mergesort je příkladem jakého algoritmického paradigmatu?",
    "options": [
      "Hladový algoritmus",
      "Dynamické programování",
      "Rozděl a panuj",
      "Backtracking",
      "Randomizovaný algoritmus"
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "algo_q3_dynamic",
    "question": "Jaký je klíčový rozdíl mezi dynamickým programováním a metodou \"rozděl a panuj\"?",
    "options": [
      "Dynamické programování nepoužívá rekurzi.",
      "Rozděl a panuj řeší pouze seřazovací problémy.",
      "Dynamické programování efektivně řeší problémy s *překrývajícími se* podproblémy tím, že si pamatuje (memoizuje) nebo tabeluje jejich výsledky, zatímco \"rozděl a panuj\" typicky řeší nezávislé podproblémy.",
      "Rozděl a panuj má vždy lepší časovou složitost.",
      "Dynamické programování je vždy implementováno iterativně (zdola nahoru)."
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "stack_queue_q1",
    "question": "Mějme seznam A = [1, 2, 3, 4]. Pokud nejprve vložíme jeho prvky do zásobníku a následně tyto prvky přesuneme do fronty, v jakém pořadí budeme prvky získávat při jejich postupném odebírání z fronty?",
    "options": [
      "[1, 2, 3, 4] - Prvky jsou odebrány ve stejném pořadí, jak byly vloženy do seznamu.",
      "[4, 1, 3, 2] - Prvky jsou odebrány v náhodném pořadí.",
      "Takto nelze ADT Zásobní a ADT Fronta řetězit.",
      "[4, 3, 2, 1] - Prvky jsou odebrány v obráceném pořadí oproti jejich vložení do seznamu."
    ],
    "correctAnswerIndex": 3
  },
  {
    "id": "dijkstra_complexity_q1",
    "question": "Jaká je složitost nejhoršího případu algoritmu hledání nejkratší cesty, založeném na Dijkstrově algoritmu? V je počet vrcholů grafu a E je počet hran grafu.<br>Algoritmus používá prioritní frontu se složitostmi operací:<br><ul><li>Vložení prvku: Θ(log V)</li><li>Odebrání minima: Θ(log V)</li><li>Snížení hodnoty klíče: Θ(log V)</li></ul>",
    "options": [
      "Θ(|E|^2 log |V|)",
      "Θ(|V|^2 log |V|)",
      "Θ(|V|^2 |E|^2 log |V|)",
      "Θ(|V| |E|^2 log |V|)"
    ],
    "correctAnswerIndex": 1
  },
  {
    "id": "python_code_output_q1",
    "question": "Co vypíše následující program?<br><pre><code>class SignatureCreator:\n    def create_signature(self) -> str:\n        return \"Signed\"\n\nclass SignAdapter:\n    def __init__(self, creator):\n        self.creator = creator\n\n    def sign(self) -> bool:\n        return self.creator.create_signature() == \"Signed\"\n\nsigning = SignAdapter(SignatureCreator())\n\nif signing.sign():\n    print(\"OK\")</code></pre>",
    "options": [
      "Signed",
      "Program vrátí chybové hlášení: AttributeError: 'SignatureCreator' object has no attribute 'sign'",
      "True",
      "OK"
    ],
    "correctAnswerIndex": 3
  },
  {
    "id": "search_partial_sort_q1",
    "question": "Mějme seřazený seznam, do kterého se vkládá je velmi zřídka. V průběhu vkládáme 5 prvků denně a v noci seznam opět seřadíme. Jaká bude průměrná algoritmická složitost vyhledání prvku v částečně seřazeném seznamu (vzhlem k délce seznamu), který má na konci v průměru 5 neseřazených prvků.<br>Uvažujte níže uvedenou implementaci vyhledávání:<br><pre><code>partially_sorted_array = [0, 5, 11, 28, 36, 71, 105] + [12, 7, 9, 3, 2]\nsorted_len = 7\ntarget = 7\nmax_unsorted_length = 5\nresult: int = -1\n\nsorted_array = partially_sorted_array[:sorted_len]\nunsorted_array = partially_sorted_array[sorted_len:]\n\nif len(unsorted_array) > max_unsorted_length:\n    print(\"The unsorted array is too long.\")\n\nleft, right = 0, len(sorted_array) - 1\nwhile left <= right:\n    mid = (left + right) // 2\n    if sorted_array[mid] == target:\n        result = mid\n        break\n    elif sorted_array[mid] < target:\n        left = mid + 1\n    else:\n        right = mid - 1\nelse: # only runs if break didn't happen in the while loop\n    for i, item in enumerate(unsorted_array):\n        if item == target:\n            result = len(sorted_array) + i\n            break\n\nprint(f\"Index of the target element: {result}\")\n</code></pre>",
    "options": [
      "Θ(n^2)",
      "Θ(log(n))",
      "Θ(n log(n))",
      "Θ(n)"
    ],
    "correctAnswerIndex": 1
  },
  {
    "id": "python_dynamic_typing_q1",
    "question": "Vyberte správná tvrzení vztahující se k dynamickému typování v Pythonu.",
    "options": [
      "Proměnným lze během provádění programu přiřadit hodnoty různých datových typů.",
      "Datové typy v Pythonu slouží pouze jako nápověda a tudíž nespecifikují operace s proměnnými.",
      "Python vyžaduje explicitní deklaraci (určení) datových typů proměnných před jejich přiřazením.",
      "Proměnné v Pythonu jsou omezeny na jeden datový typ po celou dobu své existence."
    ],
    "correctAnswerIndex": 0
  },
  {
    "id": "mergesort_bubblesort_speed_q1",
    "question": "Je zaručené, že algoritmus řazení Merge sort doběhne vždy rychleji než algoritmus Bubble sort?",
    "options": [
      "Pravda",
      "Nepravda"
    ],
    "correctAnswerIndex": 1
  },
  {
    "id": "complexity_comparison_on_omega_q1",
    "question": "Mějme algoritmus Alg1 se složitostí patřící do třídy O(n^3) a algoritmus Alg2 do třídy Ω(n^2). Jaká tvrzení o vzájemném porovnání Alg1 a Alg2 z těchto tvrzení vyplývají?",
    "options": [
      "Algoritmy neumíme na základě poskytnutých údajů porovnat.",
      "Alg1 má nižší složitost než Alg2.",
      "Alg1 má vyšší složitost než Alg2.",
      "Algoritmy mají složitost spadající do stejné třídy v Θ notaci."
    ],
    "correctAnswerIndex": 0
  },
  {
    "id": "nested_loop_complexity_q1",
    "question": "Jaká je časová složitost následujícího kódu, kde `n` odpovídá `num_lines`?<br><pre><code>def print_tree(num_lines: int) -> None:\n    for k in range(5):\n        for i in range(num_lines + k):\n            for j in range(i + 1):\n                print('*', end='')\n            print()</code></pre>",
    "options": [
        "Θ(n)",
        "Θ(5 n^3 / 2)",
        "Θ(n^2)",
        "Θ(n^3)"
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "backtracking_coin_change_q1",
    "question": "Třída složitosti nejhoršího případu algoritmu backtracking pro rozměňování mincí je Θ(m^n), kde<br><ul><li><i>n</i> je počet různých nominálních hodnot mincí.</li><li><i>m</i> je maximální počet dostupných mincí pro jakoukoliv nominální hodnotu.</li></ul>Zmíněný algoritmus najde jedno řešení. Jaká bude třída složitosti algoritmu, který najde všechna řešení? Opět uvažujeme nejhorší případ.",
    "options": [
      "Θ(mn)",
      "Θ(2^mn)",
      "Θ(m^n)",
      "Θ(2^m n)"
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "hash_function_suitability_q1",
    "question": "Je následující implementace rozptylové funkce vhodná pro použití v rozptylových tabulkách?<br><pre><code>class User:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n\n    def __hash__(self):\n        return len(self.name)</code></pre>",
    "options": [
      "Pravda",
      "Nepravda"
    ],
    "correctAnswerIndex": 1
  },
    {
    "id": "tree_traversal_complexity_q1",
    "question": "Jaká je složitost nejhoršího případu algoritmů procházení do hloubky (DFS) a do šířky (BFS) ADT strom? (n je počet vrcholů stromu)",
    "options": [
      "Θ(n) pro BFS a Θ(n^2) pro DFS.",
      "Θ(n) pro DFS a Θ(n^2) pro BFS.",
      "Θ(n) pro oba algoritmy.",
      "Θ(n^2) pro oba algoritmy."
    ],
    "correctAnswerIndex": 2
  },
  {
    "id": "jarnik_prim_fifo_q1",
    "question": "Jaký bude výsledek algoritmu hledání minimální kostry (podobného Primovu/Jarníkovu), pokud nebudeme uzly vybírat pomocí prioritní fronty podle nejnižšího ohodnocení, ale nahradíme ji normální frontou (FIFO)? (Viz implementace v testu - používá FIFO frontu a aktualizuje `min_weight` a `parent` podobně jako Prim, ale bez priority)",
    "options": [
      "Algoritmus nenajde kostru grafu.",
      "Algoritmus najde minimální kostru grafu, ovšem bude opakovaně navštěvovat již navštívené uzly a zvýší se jeho algoritmická složitost.",
      "Algoritmus najde minimální kostru grafu, ovšem bude opakovaně navštěvovat již navštívené uzly. Tím se sníží efektivita algoritmu, ale zachová se třída algoritmické složitosti Θ.",
      "Nalezená kostra nebude minimální."
    ],
    "correctAnswerIndex": 3
  },
  {
    "id": "adt_student_project_q1",
    "question": "Představme si situaci ve školním prostředí, kde učitelé z různých předmětů chtějí organizovat tematické týdny zaměřené na interdisciplinární projekty. Každý tematický týden má svou specifickou náplň, jako je \"Věda a technologie\", \"Umění a kultura\", \"Sport a zdraví\" atd. Studenti se mohou přihlásit do projektu podle svých zájmů, přičemž každý student může být součástí projektů ve více tematických týdnech. Na konci školního roku je potřeba zorganizovat slavnostní prezentaci projektů, přičemž učitelé chtějí zajistit, že budou prezentovány projekty z každého tematického týdne s co nejširším zastoupením studentů.<br><br><b>Otázka:</b> Jaký abstraktní datový typ (ADT) by byl optimální pro identifikaci studentů, kteří se přihlásili do projektů napříč různými tematickými týdny s cílem zajistit reprezentaci všech témat ve finální prezentaci a zároveň identifikovat studenty, kteří se zapojili do projektů ve více než jednom tematickém týdnu?",
    "options": [
      "ADT Množina",
      "ADT Zásobník",
      "ADT Seznam",
      "ADT Fronta"
    ],
    "correctAnswerIndex": 0
  },
  {
    "id": "adt_web_history_q1",
    "question": "Při vývoji webového prohlížeče potřebujete implementovat funkci pro správu historie procházení, kde uživatelé mohou snadno postupně vrátit zpět na předchozí stránky, na které se dívali. Která datová struktura je pro tuto úlohu nejvhodnější?",
    "options": [
      "Zásobník, protože umožňuje přidávání a odebírání prvků z vrcholu (LIFO).",
      "Fronta, protože umožňuje přidávání prvků na konec a odebírání z počátku (FIFO).",
      "Seznam, protože umožňuje vkládání a mazání prvků na libovolné pozici.",
      "Fronta, ovšem musíme zvolit implementaci spojovým seznamem."
    ],
    "correctAnswerIndex": 0
  },
  {
    "id": "python_matrix_output_q1",
    "question": "Jaké prvky vypíše následující program?<br><pre><code>matrix = [[1, 2, 3, 4, 5],\n          [6, 7, 8, 9, 10],\n          [11, 12, 13, 14, 15],\n          [16, 17, 18, 19, 20]]\n\nfor i in range(2, 3):\n    for j in range(0, 2):\n        print(matrix[i][j])\n</code></pre>",
    "options": [
      "11, 12, 13, 16, 17, 18",
      "6, 7, 8, 11, 12, 13",
      "11, 12",
      "7, 8, 9, 12, 13, 14"
    ],
    "correctAnswerIndex": 2
  }
]